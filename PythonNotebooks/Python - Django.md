## Django #1

```python
# ---------- INSTALL DJANGO ON MAC ----------

1. Check your Python version by typing in the terminal : python --version

2. You want Python 3.4 or higher. Type the following to see if you have Python 3 in the terminal : python3 --version

3. If you need Python 3.4 or above do this

	A. Download Python at https://www.python.org/downloads
	
	B. Click Download Python 3.5.1 or later
	
	C. Click Open
	
	D. Click continue a few times. Agree to the terms and install. You may have to enter your password.
	
4. Check to see if you have pip installed in the terminal type : pip --version

5. If you don't have pip 8 or above type in the terminal : sudo easy_install pip

6. Type in the terminal : sudo pip install Django

7. Test that Django is installed in the terminal

	A. python3
	
	B. import django
	
	C. django.get_version()
	
	D. You should see '1.10.2' or higher
	
8. Create a sample site : django-admin startproject sampsite

	A. sampsite is were your project lives
	
		i. __init__.py tells Python that this is a Python package
		
		ii. settings.py has settings for the Django project
		
		iii. urls.py a sort of table of contents for your project
		
		iv. wsgi.py serves your project
	
	B. manage.py allows you to interact with your project
	
9. Start the server : python manage.py runserver

# ---------- INSTALL DJANGO ON WINDOWS ----------

1. Check your Python version by typing in the terminal : python --version 
(You want Python 3.4 or higher)

2. If Python 3.4 or higher isn't installed

	A. Go to https://www.python.org/getit/windows/
	
	B. Click on Latest Python 3 Release 
	
	C. Click on Windows x86 executable installer
	
	D. Click Run
	
	E. Check Install for all users and add Python 3 to path
	
		a. Open Control Panel -> System & Security -> System -> Advanced System Settings on the left
		
		b. Environment Variable button
		
		c. Select PATH and click edit
		
		d. Add c:\Pyhon34, or what ever your Python directory is
		
3. Install Pip in the command line type : python -m pip install -U pip

4. Create a Python Virtual Environment so we don't have to worry about changing dependencies that your system may not want edited. 

	A. Type in Command Prompt : pip install virtualenv
	
	B. Create the virtual environment for your site in command prompt : virtualenv env_site1 
	
	C. Activate the environment in CP 
	
		i. cd Scripts
		
		ii. activate
		
5. Install Django in CP : pip install django

6. Test that it works

	A. python
	
	B. import django
	
	C. django.get_version()
	
	D. You should see '1.10.2' or higher
	
7. Create a sample site : django-admin startproject sampsite

	A. sampsite is were your project lives
	
		i. __init__.py tells Python that this is a Python package
		
		ii. settings.py has settings for the Django project
		
		iii. urls.py a sort of table of contents for your project
		
		iv. wsgi.py serves your project
	
	B. manage.py allows you to interact with your project
	
8. Start the server : python manage.py runserver
```

## Django #2

```python
# ---------- sampsite/views.py ----------

from django.http import HttpResponse

import random

# This is our View function which receives info
# on the request
def hello_world(request):

    # Return a response object with the text Hello World
    return HttpResponse("Hello World")

def root_page(request):

    return HttpResponse("Root Home Page")

# Receives the number passed in the url and then returns
# a random number
def random_number(request, max_rand=100):

    # Calculate a random number between 0 and the number passed
    random_num = random.randrange(0, int(max_rand))

    # Place the string and decimal in the output
    msg = "Random Number Between 0 and %s : %d" % (max_rand, random_num)

    return HttpResponse(msg)

# ---------- NOW ON TO SETTINGS ----------

# ---------- settings.py ----------

"""
Django settings for sampsite project.

Generated by 'django-admin startproject' using Django 1.10.2.

For more information on this file, see
https://docs.djangoproject.com/en/1.10/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/1.10/ref/settings/
"""

import os

# Build paths inside the project like this: os.path.join(BASE_DIR, ...)
BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))

# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/1.10/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = '1$(46qw^uc2q&c)gad(*4^y)a8g2^dbr$%)nlvyf3jygfbv70('

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

ALLOWED_HOSTS = []


# Application definition

INSTALLED_APPS = [
    # - The Django admin system
    'django.contrib.admin',

    # - The authentication system
    'django.contrib.auth',

    # - Framework for content types
    'django.contrib.contenttypes',

    # - Session Framework
    'django.contrib.sessions',

    # - Message Framework
    'django.contrib.messages',

    # - Manages static files
    'django.contrib.staticfiles',

    # 4 Include our polls app
    # 4 Run python3 manage.py makemigrations polls
    # 4 to notify Django that you have updated your Model
    # 4 Run python3 manage.py sqlmigrate polls 0001 to see
    # 4 the SQL used to create the DB
    # 4 Run python3 manage.py migrate to create the DB
    # 4 Create the models in polls/models.py
    'polls.apps.PollsConfig',
]

# 6 We can add data to the DB using the Python shell
# - python3 manage.py shell
# - Import Models : from polls.models import Question, Choice
# - Display Questions : Question.objects.all()
# - Create a Question
# - from django.utils import timezone
# - q = Question(question_text="What's New?", pub_date=timezone.now())
# - Save to the DB : q.save()
# - Get the questions id : q.id
# - Get the questions text : q.question_text
# - Get the pub date : q.pub_date
# - Change the question : q.question_text = "What's Up?"
# - Save the change : q.save()
# - Display Questions : Question.objects.all()

# 6 Change polls/models.py to provide more info on question and choice

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'sampsite.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'sampsite.wsgi.application'

# 4 Database
# https://docs.djangoproject.com/en/1.10/ref/settings/#databases

# 4 We'll use the default database of SQLite3
# - You can use other DBs, but must add USER, PASSWORD and HOST
# - django.db.backends.mysql
# - django.db.backends.postgresql
# - django.db.backends.oracle

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),
    }
}

# Password validation
# https://docs.djangoproject.com/en/1.10/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]


# Internationalization
# https://docs.djangoproject.com/en/1.10/topics/i18n/

LANGUAGE_CODE = 'en-us'

# - Change the time zone to yours using
# - https://en.wikipedia.org/wiki/List_of_tz_database_time_zones

TIME_ZONE = 'America/New_York'

USE_I18N = True

USE_L10N = True

USE_TZ = True

# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/1.10/howto/static-files/

STATIC_URL = '/static/'

# - Add a path for static files
STATIC_ROOT = os.path.join(BASE_DIR, 'static')

# ---------- sampsite/urls.py ----------

"""sampsite URL Configuration

The `urlpatterns` list routes URLs to views. For more information please see:
    https://docs.djangoproject.com/en/1.10/topics/http/urls/
Examples:
Function views
    1. Add an import:  from my_app import views
    2. Add a URL to urlpatterns:  url(r'^$', views.home, name='home')
Class-based views
    1. Add an import:  from other_app.views import Home
    2. Add a URL to urlpatterns:  url(r'^$', Home.as_view(), name='home')
Including another URLconf
    1. Import the include() function: from django.conf.urls import url, include
    2. Add a URL to urlpatterns:  url(r'^blog/', include('blog.urls'))
"""

# url matches the URL in the browser to a module
# in your Django project
from django.conf.urls import url

# Loads URLs for Admin site
from django.contrib import admin

# Reference my hello_world function
from sampsite.views import hello_world, root_page, random_number

# 3 include allows you to reference other url files
# in our project
from django.conf.urls import include

# Lists all URLs
# Add the directory in the URL you want tied to
# the hello_world function
# The r means we want to treat this like a raw string
# that ignored backslashes
# Then we define a regular expression where ^ is the
# beginning of a string, then we have the text to match
# The $ signifies the end of a Regex string

# We can pass data to a function by surrounding the part
# of the Regex to send with parentheses
# If they didn't enter a number I provide a default max
urlpatterns = [
    url(r'^admin/', admin.site.urls),
    url(r'^helloworld/$', hello_world),
    url(r'^$', root_page),
    url(r'^random/(\d+)/$', random_number),
    url(r'^random/$', random_number),

    # 3 Reference the root of the polls app
    url(r'^polls/', include('polls.urls')),
]

# 3 Test that the polls URL works by running the server
# python3 manage.py runserver
# Go to localhost:8000/polls/

# 3 Setup the database in settings.py

# ---------- polls/views.py ----------

# 1 Create the polls app inside our project
# 1 python3 manage.py startapp polls
# 1 You can have multiple apps in your project
# 1 Now we will create a view

from django.http import HttpResponse

def index(request):
    return HttpResponse("You're in the polls index")

# 1 Now attach the view to a url in urls.py

# ---------- polls/urls.py ----------

from django.conf.urls import url

from . import views

# 2 Add a reference to the view and assign it to
# the root URL for polls

urlpatterns = [
    url(r'^$', views.index, name='index'),
]

# 2 Now point the root URL file to the polls app

# ---------- polls/models.py ----------

# 5 Here you define the names and data types for
# 5 the information you are storing in your database

from django.db import models

import datetime
from django.utils import timezone

# 5 Create your models here.
# 5 Each model is a class with class variables that
# 5 represent fields in your database
# 5 After setting the column names an data types the DB
# 5 can create the table

class Question(models.Model):

    # 5 Define a DB column called question_text which
    # 5 contains text with a max size of 200
    question_text = models.CharField(max_length=200)

    # 5 This contains a date and the text passed is an
    # 5 optional human readable name
    pub_date = models.DateTimeField('date published')

    # 7 Return the text for the question when the Question
    # 7 is called by editing __str__

    def __str__(self):
        return self.question_text

    # 7 Here is a custom method for returning whether
    # 7 the question was published recently
    def was_published_recently(self):
        return self.pub_date >= timezone.now() - datetime.timedelta(days=1)

class Choice(models.Model):

    # 5 Define that each choice is related to a single
    # 5 Question
    question = models.ForeignKey(Question, on_delete=models.CASCADE)
    choice_text = models.CharField(max_length=200)
    votes = models.IntegerField(default=0)

    # 7 Return the Choice text as well
    def __str__(self):
        return self.choice_text

    # 7 Let's test our changes : python3 manage.py shell
    # 7 from polls.models import Question, Choice
    # 7 Get a detailed list of questions
    # 7 Question.objects.all()

    # 7 Get the Question with the matching id
    # 7 Question.objects.filter(id=1)

    # 7 Get the question that starts with What
    # 7 Question.objects.filter(question_text__startswith='What')

    # 7 Get Question published this year
    # 7 from django.utils import timezone
    # 7 current_year = timezone.now().year
    # 7 Question.objects.get(pub_date__year=current_year)

    # 7 If you request something that doesn't exist you
    # 7 raise an exception
    # 7 Question.objects.get(id=2)

    # 7 Search for primary key
    # 7 Question.objects.get(pk=1)

    # 7 Test was_published_recently()
    # 7 q = Question.objects.get(pk=1)
    # 7 q.was_published_recently()

    # 7 Show choices for matching question
    # 7 q.choice_set.all()

    # 7 Add new choices
    # 7 q.choice_set.create(choice_text='Not Much', votes=0)
    # 7 q.choice_set.create(choice_text='The Sky', votes=0)
    # 7 q.choice_set.create(choice_text='The Clouds', votes=0)

    # 7 Display choices
    # 7 q.choice_set.all()

    # 7 Display number of choices
    # 7 q.choice_set.count()

    # 7 Show all choices for questions published this year
    # 7 Use __ to separate relationships
    # 7 Choice.objects.filter(question__pub_date__year=current_year)

    # 7 Delete a choice
    # 7 c = q.choice_set.filter(choice_text__startswith='The Clouds')

# 5 After defining the model we include the app in our project
# 5 under INSTALLED_APPS in settings.py
```

## Django #3

```
# ---------- /polls/admin.py ----------

# 1 Django automates the interface used to add, change
# and delete content
# To create a user : python3 manage.py createsuperuser
# Username: admin
# Email address: db@compuserve.com
# Enter passwords

# 1 Run the server : python3 manage.py runserver
# Open localhost:8000/admin

# 1 Tell admin that our poll system has an admin interface
# in polls/admin.py

# 1 You can change any of the options and click History
# to see a list of the changes
# You can also add or delete questions

# 1 Now add more views in polls/views.py

from django.contrib import admin

# Register your models here.

# - Import Question
from .models import Question

# - Register Question for showing in admin
admin.site.register(Question)

# ---------- /polls/views.py ----------

from django.http import HttpResponse

# 7 Opens a 404 page if get doesn't supply a result
from django.shortcuts import get_object_or_404

# 2 Each view is represented by a function
# We'll create :
# index : Display the latest questions
# detail : Display the question and the choices
# results : Display question results

# - Original index function
'''
def index(request):
    return HttpResponse("You're in the polls index")
'''

# 4
# Import Question and Choice from our models file
from .models import Question, Choice

'''
# 4 New index function
def index(request):

    # 4 Receive a list of 5 questions ordered by date
    latest_question_list = Question.objects.order_by('-pub_date')[:5]

    # 4 Cycle through the questions to create a list
    output = ', '.join([q.question_text for q in latest_question_list])

    # Return the text to display
    return HttpResponse(output)

'''

# 4 This isn't the best solution because the results are
# hard coded into the Python. Let's use a template to
# separate the design from the code
# Create a directory named templates in polls
# Create a directory named polls in the templates directory
# Create a file named index.html in that polls directory
# and create the template

# 6 Create a new index function that sends the question list
# to the template

# 6 Renders a page when it is passed a template and
# any data required by the template
from django.shortcuts import render

def index(request):
    latest_question_list = Question.objects.order_by('-pub_date')[:5]

    # 6 Define the name for the data to pass to the template
    context = {
        'latest_question_list': latest_question_list,
    }

    # 6 Render the page in the browser using the template
    # and data required by the template
    return render(request, 'polls/index.html', context)


# 2 add these 3 new views

'''
def detail(request, question_id):
    return HttpResponse("You're looking at question %s" % question_id)
'''

'''
def results(request, question_id):
        response = "You're looking at the results of question %s"
        return HttpResponse(response % question_id)
'''

# 10 Let's update results() to show voting results
def results(request, question_id):

    # 10 Get the question id passed or 404
    question = get_object_or_404(Question, pk=question_id)

    # 10 Render the template
    return render(request, 'polls/results.html',
                  {'question': question})

# 10 Now create /templates/polls/results.html template

'''
def vote(request, question_id):
    return HttpResponse("You're voting on question %s" % question_id)

# 7 Let's update detail to use a 404 page and template
'''

# 9 Now we will update vote() to except the choice picked

# 9 Used to avoid receiving data twice from a form if the user
# clicks the back button
from django.http import HttpResponseRedirect

# 9 Used to return a url we can point to based on the
# current question we are dealing with
from django.urls import reverse

def vote(request, question_id):
    question = get_object_or_404(Question, pk=question_id)

    # 9 Try to get the selected radio button
    try:
        selected_choice = question.choice_set.get(pk=request.POST['choice'])

    except(KeyError, Choice.DoesNotExist):

        # 9 Re-render the form
        return render(request, 'polls/detail.html', {
            'question': question,
            'error_message': "You didn't select a choice"
        })
    else:

        # 9 If a choice was selected increment it in the DB
        selected_choice.votes += 1
        selected_choice.save()

        # 9 Protect from data being sent twice if user clicks back
        return HttpResponseRedirect(reverse('polls:results', args=(question.id,)))


def detail(request, question_id):
    # 7 Check if the page exists, or display 404 page
    question = get_object_or_404(Question, pk=question_id)

    return render(request, 'polls/detail.html', {'question': question})

# 7 Now create the detail.html template in templates/polls/

# 2 Add them to polls/urls.py


# ---------- /polls/urls.py ----------

from django.conf.urls import url

from . import views

# 3 Add a namespace so Django knows what directory to load
# if another app has views with the same name
app_name = 'polls'

urlpatterns = [
    url(r'^$', views.index, name='index'),
    # 3 Add the 3 views
    # The data surrounded by parentheses is sent to the function
    # ?P<question_id> defines the name for the data within
    # the parentheses
    # [0-9]+ says we will match 1 or more numbers
    url(r'^(?P<question_id>[0-9]+)/$', views.detail, name='detail'),
    url(r'^(?P<question_id>[0-9]+)/results/$', views.results, name='results'),
    url(r'^(?P<question_id>[0-9]+)/vote/$', views.vote, name='vote'),
]

# 3 Now let's update polls/views.py

# ---------- /polls/templates/polls/index.html ----------

<!-- 5 If a list of questions is available create
an unordered list of the questions or print
that none are available -->
{% if latest_question_list %}
    <ul>
        {% for question in latest_question_list %}
            <li>
                <!-- 5 url defines directory to open based
                 on using the namespace defined in polls/urls.py
                 and the url defined in sampsite/urls.py -->
                <a href="{% url 'polls:detail' question.id %}">{{question.question_text}}</a>
            </li>
        {% endfor %}
    </ul>
{% else %}
    <p>No polls are available</p>
{% endif %}

<!-- 5 Back to polls/views.py to update index -->

# ---------- /polls/templates/polls/detail.html ----------

<!-- 8 Display the question passed and the choices
available -->

<h1>{{question.question_text}}</h1>

<!-- 8 Display error message -->
{% if error_message %}
<p><strong>{{error_message}}</strong></p>
{% endif %}

<!-- 8 Create a form which allows users to pick a choice -->
<!-- Point at the vote function in polls/views.py using
the namespace and pass the question id -->
<form action="{% url 'polls:vote' question.id %}" method="post">

<!-- 8 Protects your site from Cross Site Request Forgeries
which occur when another site tries to target your form -->
{% csrf_token %}

<!-- 8 Cycle through all choices for this question and
create a radio button for each -->
{% for choice in question.choice_set.all %}

    <!-- 8 When submitted the choice id is sent -->
    <input type="radio" name="choice"
           id="choice{{ forloop.counter }}"
           value="{{ choice.id }}" />

    <label for="choice{{ forloop.counter }}">{{ choice.choice_text }}</label>
    <br>

{% endfor %}

<input type="submit" value="Vote" />
</form>

<!-- 8 Now update the vote function in polls/views.py -->

# ---------- /polls/templates/polls/results.html ----------

<!-- 11 Displays choice results for the passed question -->

<h1>{{question.question_text}}</h1>

<!-- Cycle through all the choices for the question -->
<ul>
    {% for choice in question.choice_set.all %}
        <li>
            <!-- Add a s to vote if not 1 -->
            {{choice.choice_text}} -- {{choice.votes}} vote{{choice.votes|pluralize}}
        </li>
    {% endfor %}
</ul>

<a href="{% url 'polls:detail' question.id %}">Vote Again</a>
```

## Django Testing

```
# ---------- /polls/urls.py ----------

# 1 Generic views are normally used from the beginning
# and they help you avoid having to write a lot
# of custom code

from django.conf.urls import url

from . import views

app_name = 'polls'

# 1 We'll change the urlpatterns

urlpatterns = [
    url(r'^$', views.IndexView.as_view(), name='index'),
    url(r'^(?P<pk>[0-9]+)/$', views.DetailView.as_view(), name='detail'),
    url(r'^(?P<pk>[0-9]+)/results/$', views.ResultsView.as_view(), name='results'),
    url(r'^(?P<question_id>[0-9]+)/vote/$', views.vote, name='vote'),
]

# 1 Now remove our index, detail and results views in polls/views.py

'''
urlpatterns = [
    url(r'^$', views.index, name='index'),
    url(r'^(?P<question_id>[0-9]+)/$', views.detail, name='detail'),
    url(r'^(?P<question_id>[0-9]+)/results/$', views.results, name='results'),
    url(r'^(?P<question_id>[0-9]+)/vote/$', views.vote, name='vote'),
]
'''

# ---------- /polls/views.py ----------

from django.http import HttpResponse

from .models import Question, Choice

from django.shortcuts import render

from django.shortcuts import get_object_or_404

from django.http import HttpResponseRedirect

from django.urls import reverse

# 2 Add the generic module
from django.views import generic

# 8 Import so we can get time information
from django.utils import timezone

# 2 The ListView displays your list of questions being
# latest_question_list
class IndexView(generic.ListView):
    template_name = 'polls/index.html'

    # 2 This defines the question list we want to use
    context_object_name = 'latest_question_list'

    # 8 Replace get_queryset and don't return questions
    #  published in the future
    '''
    def get_queryset(self):

        # 2 Return the last 5 questions entered
        return Question.objects.order_by('-pub_date')[:5]
    '''

    def get_queryset(self):

        # 8 Return only questions with a pub_date less than
        # or equal to now
        return Question.objects.filter(
            pub_date__lte=timezone.now()
        ).order_by('-pub_date')[:5]

        # 8 Add Choices to the Admin in admin.py

# 2 The DetailView displays the details on your object
# being the Question model

# 2 The generic view expects the pk (Primary Key) value
# from the URL to be called pk as we set in polls/urls.py
class DetailView(generic.DetailView):
    model = Question

    # 2 Define the template to use with this data
    template_name = 'polls/detail.html'

    # 12 Exclude questions that are not published yet
    def get_queryset(self):
        return Question.objects.filter(pub_date__lte=timezone.now())

    # 12 Add tests in polls/tests.py

# 2
class ResultsView(generic.DetailView):
    model = Question
    template_name = 'polls/results.html'


# 2 Remove these functions

'''
def index(request):
    latest_question_list = Question.objects.order_by('-pub_date')[:5]

    context = {
        'latest_question_list': latest_question_list,
    }

    return render(request, 'polls/index.html', context)

def detail(request, question_id):

    question = get_object_or_404(Question, pk=question_id)

    return render(request, 'polls/detail.html', {'question': question})

def results(request, question_id):

    question = get_object_or_404(Question, pk=question_id)

    return render(request, 'polls/results.html', {'question': question})
'''

# 2 Vote stays the same
def vote(request, question_id):
    question = get_object_or_404(Question, pk=question_id)

    try:
        selected_choice = question.choice_set.get(pk=request.POST['choice'])

    except(KeyError, Choice.DoesNotExist):
        return render(request, 'polls/detail.html', {
            'question': question,
            'error_message': "You didn't select a choice"
        })
    else:
        selected_choice.votes += 1
        selected_choice.save()

        return HttpResponseRedirect(reverse('polls:results', args=(question.id,)))

# 3 Now we will explore automated testing. You can either
# check your code by entering values randomly (and miss
# a bunch of errors), or you can automate the process.

# 3 We'll now explore a bug in the was_published_recently() function
# in polls/models.py in the shell : python3 manage.py shell

# 3 Create a Question with a pub_date in the future
'''
import datetime
from django.utils import timezone
from polls.models import Question
future_question = Question(pub_date=timezone.now() + datetime.timedelta(days=30))
future_question.was_published_recently()
Returns true even though that doesn't make sense
'''

# 3 Open the file called tests.py


# ---------- /polls/tests.py ----------

from django.test import TestCase

# 4 Import your needed modules
import datetime
from django.utils import timezone
from django.test import TestCase

from .models import Question

# 4 TestCase runs tests without effecting your data
# by creating a temporary database for testing
class QuestionMethodTests(TestCase):

    # 4 Put the code used in the shell here
    # Start the method name with test
    def test_was_published_recently_with_future_question(self):

        # 4 Create a time 30 days in the future
        time = timezone.now() + datetime.timedelta(days=30)

        # 4 Create a question using the future time
        future_question = Question(pub_date=time)

        # 4 Check to see if the output is False like we expect
        self.assertIs(future_question.was_published_recently(), False)

        # 4 Run the test in the terminal
        # python3 manage.py test polls
        # You'll see that the test failed

        # 4 Fix the bug in models.py

    # 6 Return false if pub_date is older then 1 day

    def test_was_published_recently_with_old_question(self):
        # Should return false if pub_date is older then 1 day
        time = timezone.now() - datetime.timedelta(days=30)
        old_question = Question(pub_date=time)
        self.assertIs(old_question.was_published_recently(), False)

    # 6 Return True if published within the last day

    def test_was_published_recently_with_recent_question(self):
        time = timezone.now() - datetime.timedelta(hours=1)
        recent_question = Question(pub_date=time)
        self.assertIs(recent_question.was_published_recently(), True)

    # 6 Test with : python3 manage.py test polls

    # 7 We can simulate user interaction at the view level in the shell
    # python3 manage.py shell
    '''
    # This allows us access variable values in our templates
    # We will be using our real database here
    from django.test.utils import setup_test_environment
    setup_test_environment()

    # Create the client that we'll use to run our app
    from django.test import Client
    client = Client()

    # Get the status code from localhost:8000/
    response = client.get('/')
    response.status_code

    # Get the status code for localhost:8000/polls/
    from django.urls import reverse
    response = client.get(reverse('polls:index'))
    response.status_code

    # Get the HTML content
    response.content

    # Get the value of latest_question_list
    response.context['latest_question_list']
    '''

    # 7 Let's update polls/views.py so it doesn't show
    # questions published in the future

    # 10 Create a function that creates questions at
    # a specified date

    def create_question(question_text, days):
        time = timezone.now() + datetime.timedelta(days=days)
        return Question.objects.create(question_text=question_text,
                                       pub_date=time)

# 10 Add more question tests

class QuestionViewTests(TestCase):

    # 10 Test to see what happens if there are no questions
    def test_index_view_with_no_questions(self):

        # Get the client
        response = self.client.get(reverse('polls:index'))

        # Check the status code
        self.assertEqual(response.status_code, 200)

        # Verify that response contains this string
        self.assertContains(response, "No polls are available.")

        # Check if latest_question_list is empty
        self.assertQuerysetEqual(response.context['latest_question_list'], [])

    # 10 Make sure questions with a pub_date in past are shown
    def test_index_view_with_a_past_question(self):

        # Create sample question
        create_question(question_text="Past question.", days=-30)

        # Get client
        response = self.client.get(reverse('polls:index'))

        # Verify that the question shows
        self.assertQuerysetEqual(
            response.context['latest_question_list'],
            ['<Question: Past question.>']
        )

    # 10 Make sure questions with future pub_date don't show
    def test_index_view_with_a_future_question(self):

        # Create question
        create_question(question_text="Future question.", days=30)

        # Get client
        response = self.client.get(reverse('polls:index'))

        # Verify response contains text
        self.assertContains(response, "No polls are available.")

        # Verify that latest_question_list is empty
        self.assertQuerysetEqual(response.context['latest_question_list'], [])

    # 10 Verify that if past and future questions exist that only
    # past show
    def test_index_view_with_future_question_and_past_question(self):

        # Create questions
        create_question(question_text="Past question.", days=-30)
        create_question(question_text="Future question.", days=30)

        # Get client
        response = self.client.get(reverse('polls:index'))

        # Verify that question list only contains past questions
        self.assertQuerysetEqual(
            response.context['latest_question_list'],
            ['<Question: Past question.>']
        )

    # 10 Make sure question list shows multiple questions
    def test_index_view_with_two_past_questions(self):

        # Create questions
        create_question(question_text="Past question 1.", days=-30)
        create_question(question_text="Past question 2.", days=-5)

        # Create client
        response = self.client.get(reverse('polls:index'))

        # Verify that both questions show
        self.assertQuerysetEqual(
            response.context['latest_question_list'],
            ['<Question: Past question 2.>', '<Question: Past question 1.>']
        )

# 11 Make sure future questions can't be accessed if the user
# guess the URL in polls/views.py

# 13 Add tests to make sure future posts aren't shown in detail

class QuestionIndexDetailTests(TestCase):

    # 13 Make sure future question detail pages show 404
    def test_detail_view_with_a_future_question(self):

        # Create question
        future_question = create_question(question_text='Future question.', days=5)

        # Open url using the future question in the url
        url = reverse('polls:detail', args=(future_question.id,))

        # Get client response
        response = self.client.get(url)

        # Verify that it returns 404
        self.assertEqual(response.status_code, 404)

    # 13 Verify that past questions show in detail
    def test_detail_view_with_a_past_question(self):

        # Create question
        past_question = create_question(question_text='Past Question.', days=-5)

        # Open url with past question
        url = reverse('polls:detail', args=(past_question.id,))

        # Get response
        response = self.client.get(url)

        # Verify the question shows
        self.assertContains(response, past_question.question_text)


# ---------- /polls/models.py ----------

from django.db import models

import datetime
from django.utils import timezone

class Question(models.Model):
    question_text = models.CharField(max_length=200)

    pub_date = models.DateTimeField('date published')

    def __str__(self):
        return self.question_text

    def was_published_recently(self):
        # 5 return self.pub_date >= timezone.now() - datetime.timedelta(days=1)
        # 5 Fix the code
        now = timezone.now()
        return now - datetime.timedelta(days=1) <= self.pub_date <= now

        # 5 Now the test will pass

        # 5 Add further tests to polls/tests.py

class Choice(models.Model):

    question = models.ForeignKey(Question, on_delete=models.CASCADE)

    choice_text = models.CharField(max_length=200)
    votes = models.IntegerField(default=0)

    def __str__(self):
        return self.choice_text


# ---------- /polls/admin.py ----------

from django.contrib import admin

# 9 Add choice to imports

from .models import Question, Choice

admin.site.register(Question)

# 9 Add Choice to the Admin page
admin.site.register(Choice)

# 9 Create some future questions

# 9 Add some tests in polls/tests.py
```

## Django #5

```
# ---------- /polls/index.html ----------

<!-- 1 Aside from HTML that is defined in your templates
 you also need images, JavaScript, and CSS for generating
 web pages. We store those in the static directory. -->

<!-- 1 Create directory /polls/static/polls and define
style.css there -->

<!-- 3 Add the style sheet by pointing to the static directory-->
{% load static %}

<link rel="stylesheet" type="text/css" href="{% static 'polls/style.css' %}" />

<!-- 4 Create the directory /polls/static/polls/images and
save a repeating background image named background.png there -->

<!-- 4 Add the image as a background in style.css -->

{% if latest_question_list %}
    <ul>
        {% for question in latest_question_list %}
            <li>
                <a href="{% url 'polls:detail' question.id %}">{{question.question_text}}</a>
            </li>
        {% endfor %}
    </ul>
{% else %}
    <p>No polls are available</p>
{% endif %}

# ---------- /polls/static/polls/style.css ----------

/* 2 Change the text color of links in lists.
 Go to /polls/templates/polls/index.html to
 add the style sheet */

li a {
    color: green;
}

/* 5 Add the background */

body {
    background: white url("images/background.png");
}

/* 6 Now customize the admin page in /polls/admin.py */

# ---------- /polls/admin.py ----------

from django.contrib import admin

from .models import Question, Choice

# 9 Set up the Choice options on the Question page
# extra = 3 says to provide 3 extra choice options by
# default

# 9.a Change StackedInline to TabularInline to
# take up less space

class ChoiceInline(admin.TabularInline):
    model = Choice
    extra = 3

# 7 You can change the order of how items show up
# like this

class QuestionAdmin(admin.ModelAdmin):
    # 7 fields = ['pub_date', 'question_text']

    # 8 You can also break up the data in blocks
    ''' 9 Add choices to Question page
    fieldsets = [
        (None, {'fields': ['question_text']}),
        ('Date Information', {'fields': ['pub_date']}),
    ]
    '''

    # 9 Updated fieldsets
    # collapse collapses a field by default
    fieldsets = [
        (None, {'fields': ['question_text']}),
        ('Date Information', {'fields': ['pub_date'], 'classes': ['collapse']}),
    ]
    inlines = [ChoiceInline]

    # 10 Change the Question list page to display the
    # date published and whether it is recent

    list_display = ('question_text', 'pub_date', 'was_published_recently')

    # 11 Over to polls/models.py to fix was_published_recently

    # 14 Add a filter box that lets the user sort by
    # pub_date
    list_filter = ['pub_date']

    # 14 Allow the user to search by question text
    search_fields = ['question_text']

    # 15 Over to sampsite/settings.py to change the page title

# admin.site.register(Question)

# 7 Pass your change to register
admin.site.register(Question, QuestionAdmin)

# 9 Don't have Choice be on its own page
# admin.site.register(Choice)

# ---------- sampsite/settings.py ----------

Change Just this Part of Settings

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        # 16 Change 'DIRS': [], to
        'DIRS': [os.path.join(BASE_DIR, 'templates')],
        # 16 That well tell Django to look in the templates dir
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

# 17 Create a templates/admin directory in the dir that contains
# manage.py

WSGI_APPLICATION = 'sampsite.wsgi.application'

# 17 Find the current base_site.html template by typing
# this in your terminal
# python -c "import django; print(django.__path__)"
# Copy the contents of the file base_site.html in the directory
# templates

# ---------- sampsite/templates/admin/base_site.html ----------

{% extends "admin/base.html" %}

{% block title %}{{ title }} | {{ site_title|default:_('Django site admin') }}{% endblock %}

<!-- 18 Change this -->

<!--
{% block branding %}
<h1 id="site-name"><a href="{% url 'admin:index' %}">{{ site_header|default:_('Django administration') }}</a></h1>
{% endblock %}
-->

<!-- To this -->

{% block branding %}
<h1 id="site-name"><a href="{% url 'admin:index' %}">Polls Administration</a></h1>
{% endblock %}

{% block nav-global %}{% endblock %}

# ---------- /polls/models.py ----------

from django.db import models

import datetime
from django.utils import timezone

class Question(models.Model):
    question_text = models.CharField(max_length=200)

    pub_date = models.DateTimeField('date published')

    def __str__(self):
        return self.question_text

    def was_published_recently(self):
        now = timezone.now()

        return now - datetime.timedelta(days=1) <= self.pub_date <= now

    # 12 Sort published recently based on pub_date
    was_published_recently.admin_order_field = 'pub_date'

    # 12 If boolean is true it will display an icon rather then value
    was_published_recently.boolean = True

    # 12 Change the description at the top of the table
    was_published_recently.short_description = 'Published Recently?'

    # 13 Back to polls/admin.py

class Choice(models.Model):

    question = models.ForeignKey(Question, on_delete=models.CASCADE)

    choice_text = models.CharField(max_length=200)
    votes = models.IntegerField(default=0)

    def __str__(self):
        return self.choice_text
```